\title{Development Report}
\author{
  \textbf{Author}\\
  Jack Ellis \\
  psyje5@nottingham.ac.uk\\
  4262333\\\\
  \textbf{Supervisor}\\
  Natasa Milic-Frayling\\
  psznm@nottingham.ac.uk
}
\date{}
\documentclass[12pt, a4paper]{report}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{mathtools}
\lstset{
  basicstyle=\ttfamily\small,
  language=Haskell
}

\graphicspath{ {Images/} }
\begin{document}
\maketitle

\tableofcontents
\pagebreak

\section{Drawing A Window}

The first stage of development for the game is to draw a window.
Per the specifications set out in my interim report, this window is to be 640 pixels wide by 480 pixels tall.
I first created a file called \verb|Main.hs|; this can be thought of as analagous to the \verb|main| function often found in imperative languages as the "point of entry" for a given program.
Here I first declared it as a module called \verb|Main|, and then declared the \verb|main| function itself.
Again similar to an imperative language, this is the function that will be called once the program is compiled and run.
It is a function of type \verb|IO()|, meaning that ultimately all it does is perform some \verb|IO| action, some action with a side effect; it takes no arguments and returns no value that can be passed into another function.
These functions often consist of multiple commands chained in a manner that could look imperative to some however, as we shall see, this is not necessarily the case.
To begin with we must initialise GLUT; this allows it to begin working and set up a session with the window system in use.
The function \verb|getArgsAndInitialize| also returns a tuple, with a string representing argument 0 (the program name) as the first element, and a list of strings representing the remaining arguments as the second.
To again liken it to an imperative language, this is the \verb|(int argc, char* argv)| seen so often in C and C-style \verb|main| functions.

\par

Now that the window session is initialised we must provide it with some parameters with which to draw a window.
In my motivation for doing this I said that Haskell does not provide users with the ability to declare global variables.
The GLUT library however does, via a module called \verb|StateVar|.
The library has a number of such \verb|StateVar| variables, many of which will be explored as this program becomes more and more complex, but for the moment the one that is of use to us is the \verb|initialWindowSize| variable.
This is of type \verb|StateVar Size|, where \verb|Size| is a type defined in the GLUT library as little more than a wrapper for two numbers - a more readily understood tuple.
We can use the \verb|$=| operator as a "setter" for \verb|StateVar| variables, and with it we can set the window's initial size to 640x480 pixels.

\par

With the required settings now correct we can call \verb|createWindow|, passing the string "Frogger" as the window's title, and the program should compile and run.
It does not, however, because we are missing something.
If we try to compile the code we get the following error:

\begin{lstlisting}[language=sh, xleftmargin=-0.1\textwidth, xrightmargin=-0.1\textwidth]
GLUT Warning: The following is a new check for GLUT 3.0; update your code.
GLUT Fatal Error: redisplay needed for window 1, but no display callback.
\end{lstlisting}

We need to set a \verb|DisplayCallback|, essentially a function describing how to draw things within the created window at each refresh.
In order to keep things clean this function will be declared in its own module, \verb|Display|.
Currently we're only interested in drawing the window in the first place, so we can just tell it to first clear the \verb|ColorBuffer| - setting the whole content of the window to black - and then \verb|flush|, which empties all command buffers, executing the commands as quickly as possible so as to ensure the image is as expected by the user.

\par

\begin{figure}[ht]
  \centering
  \caption{The blank window drawn.}
  \includegraphics[width=0.5\textwidth]{DrawingAWindow.png}
  \label{fig:drawingawindow}
\end{figure}

With that done, we now have a window being drawn!
It is however just a blank, black-filled window, as seen in Figure \ref{fig:drawingawindow}.
In the next section we will add the game's titular \textit{Frogger}.

\section{Adding A Character}

Now that we have a window to draw in, we should draw something in it.
How better to start than with the hero of the game, the titular \textit{Frogger}?
Let's first represent him as a green unit square, just to get to grips with the coordinate and scaling system in Haskell's GLUT library.

\par

First we need to set the current drawing colour to green, which is easily done using GLUT's \verb|color| function.

\begin{lstlisting}
color $ Color3 0.0 1.0 (0.0 :: Float)
\end{lstlisting}
$

This function sets the current drawing colour to whatever is passed into it, which in our case is a \verb|Color3| type (similar to the \verb|Size| type described earlier), with the 3 values representing red, green, and blue values.
Worth noting is that in Haskell anything that follows a lone \$ is thought of as being in parentheses, so the above is semantically identical to this:

\begin{lstlisting}
color (Color3 0.0 1.0 (0.0 :: Float))
\end{lstlisting}

Now that we have the correct colour selected we can draw a quadrilateral, which we can do with the \verb|renderPrimitive Quads| function, as follows:

\begin{lstlisting}[xleftmargin=-0.1\textwidth, xrightmargin=-0.1\textwidth]
let p = [(1,0,0),(1,1,0),(0,1,0),(0,0,0)] :: [(Float,Float,Float)]
renderPrimitive Quads $ mapM_ (\(x,y,z) -> vertex $ Vertex3 x y z) p
\end{lstlisting}

Let's unpack this a little bit.
The \verb|let| command is more or less the same as a variable declaration on the "global" scope, like declaring a variable \verb|myVar :: Int| with a value of \verb|5|, only limited to the scope of the function in which it is declared.
It is a local variable, essentially.
\verb|p| is a list of tuples, each containing 3 \verb|Float| values.
These values are the x, y, and z coordinates for each of the points of the quadrilateral we're drawing, respectively.
The reason their type is declared explicitly here is that otherwise the compiler throws an error relating to ambiguous types, and because we don't want to clog up the rest of the program with values that no other function is ever going to need to know exists we append to the "local variable declaration" an explicit type declaration.
The coordinates described by \verb|p| denote a unit square extending from what would be considered the origin on a mathematical graph in positive x and y.
The next line is the fun one, let's go through it piece by piece.
\verb|renderPrimitive| is the foundation for this; it does the actual drawing of what is fed into it.
\verb|Quads| is one of the options for "ways to draw", it means draw the following as a closed quadrilateral or series or separate closed quadrilaterals.
Other options here include drawing something as a wire frame, triangles, a single polygon, or just points.
The argument passed in here is a version of \verb|p| that has had a lambda function\footnote{lambda functions are anonymous functions written in the style of the lambda calculus. They are convenient when you need to do something slightly complicated but that will only ever get used in that one place.} mapped over it.
This lambda function takes a tuple of three values and, using two of the GLUT library's provided data constructors, converts them into a type accepted by \verb|renderPrimitive|.

\par

So with all of these in place we should have a unit square drawn nicely on the screen, right?
Let's see.

\begin{figure}[ht]
  \centering
  \caption{A "unit square" - this is a result of the way in which GLUT draws and populates a window by default.}
  \includegraphics[width=0.5\textwidth]{DrawingACharacter.png}
  \label{fig:drawingacharacter}
\end{figure}

Oh dear.
As we can see in Figure \ref{fig:drawingacharacter} this square is much too large, and begins centered on the screen, rather than how it should be - in my opinion - specifically starting at the bottom left of the window.
Conveniently GLUT provides functions for both scaling and translating, so this shouldn't be a problem!

\par

Something worth noting before we continue is that it is very important to get the scaling and translation done in the correct order; in general translation should be done first, because scaling actually affects translation.
Mathematically speaking they are not commutative actions, in particular because they are both examples of matrix multiplication.

\par

The translation and scaling should be done before any other part of the display, given that they directly impact all other parts of drawing.
They are both one-line functions taking similar forms:

\begin{lstlisting}
translate $ Vector3 (-1.0) (-1.0) (0.0 :: Float)
scale (1.0/32.0) (1.0/24.0) (0.0 :: Float)
\end{lstlisting}
$

The main difference is that \verb|translate| takes a \verb|Vector3| data type as an argument, whereas \verb|scale| takes only 3 \verb|Float|s.
\verb|translate| moves the drawing "origin" in a way described by the coordinates in its argument; before any scaling happens a GLUT window essentially consists of 4 "1x1" quadrants (these are stretched to fill the aspect ratio of the window they're in).
The \verb|scale| function scales everything drawn after it is called by a factor of the first argument in x, second argument in y, and third argument in z.
Here the scale factors are \verb|1/32| in x and \verb|1/24| in y, these are both based on the window size in their respective direction and, because the window is effectively 2 units both across and tall, it should be scaled to $2/$ that value, and the fractions have been reduced manually.
Here one unit size is equivalent to 10 pixels, and so now we have a unit square as shown in Figure \ref{fig:drawingacharacterproperly}

\begin{figure}[ht]
  \centering
  \caption{The unit square denoting our \textit{Frogger} is now an appropriate size.}
  \includegraphics[width=0.5\textwidth]{DrawingACharacterProperly.png}
  \label{fig:drawingacharacterproperly}
\end{figure}

Now we have a character drawn and scaled appropriately.
Next let's give him some movement, by way of keyboard input.

\section{Keyboard Input}

Keyboard input is handled by way of another callback in the Haskell GLUT system, however implementing it will require some additional plumbing being added first.
Specifically it will require the introduction of one of the major building blocks of this program, the \verb|IORef|.
This is Haskell's way of making use of the IO Monad to do things that it, as a language, would rather not, in this instance global variables and states.
Firstly however we must declare what kind of variable it is we want to be global.
We do that in a new file, \verb|Type.hs|, which will be the point from which we declare all new types and functions relating to them.
For now we will only have one type, the \verb|Mover|, based on the \verb|MovingEntity| superclass in the GitHub project reported on elsewhere.

\begin{lstlisting}
data Mover = Frogger {x :: Float,
                      y :: Float
                     }
\end{lstlisting}

This is a "record-style" data type with two fields: x and y, denoting the x and y coordinates of the \textit{Frogger}.
With this in place we can add the \verb|Type| module to \verb|Main| and, after creating the window, create a new \verb|IORef Mover| with \verb|x| and \verb|y| both set to 0.0.

% TODO: unescape $
\begin{lstlisting}
f <- newIORef \$ Frogger {x = 0.0, y = 0.0}
\end{lstlisting}

Finally before we set up the \verb|keyboardMouseCallback|, we modify the \verb|display| function to take as an argument an \verb|IORef Mover|, and draw the character based on it.
This requires that we change 3 lines of the function, resulting in:

\begin{lstlisting}
display :: IORef Mover -> DisplayCallback
display m =
  do clear [ColorBuffer]
     loadIdentity
     fr <- get m
     translate $ Vector3 (-1.0) (-1.0) (0.0 :: Float)
     scale (1.0/320.0) (1.0/240.0) (0.0 :: Float)
     color $ Color3 0.0 1.0 (0.0 :: Float)
     let p = [(x fr + 10,y fr,0),
              (x fr + 10,y fr + 10,0),
              (x fr,y fr + 10,0),
              (x fr,y fr,0)] :: [(Float,Float,Float)]
     renderPrimitive Quads $ mapM_ (\(x,y,z) -> vertex $ Vertex3 x y z) p
     flush
\end{lstlisting}

\verb|loadIdentity| is a very important function in all of this - it resets the modification matrix, which is to say that it resets the scaling and translation applied in the last call to the function.
If this function is forgotten the screen is simply left blank with no explanation as to why.
With all of that done, we can now create the file \verb|Input.hs|, which will contain all of the functions required to deal with keyboard and mouse inputs.
In our case we want the WASD keys to be responsible for movement, which we can by defining a function \verb|input| which takes as an argument an \verb|IORef Mover| and returns a \verb|KeyboadMouseCallback|, which we will set the global \verb|keyboardMouseCallback| to in \verb|Main.hs|.
A \verb|keyboardMouseCallback| takes 5 arguments: our Mover variable, the key being pressed, that key's state (up or down), any modifier keys (Shift, Ctrl, Alt), and a position.
Our \verb|input| function can thus be described as follows.

\begin{lstlisting}[xleftmargin=-0.1\textwidth, xrightmargin=-0.1\textwidth]
input :: IORef Mover -> KeyboardMouseCallback
input m c Down _ _
  | c == (Char 'w') || c == (Char 'W') = m $~! \f -> f {y = y f + step}
  | c == (Char 'a') || c == (Char 'A') = m $~! \f -> f {x = x f - step}
  | c == (Char 's') || c == (Char 'S') = m $~! \f -> f {y = y f - step}
  | c == (Char 'd') || c == (Char 'D') = m $~! \f -> f {x = x f + step}
  | otherwise                          = return ()
  where step = 5
input _ _ _ _ _ = return ()
\end{lstlisting}

With this we now have a \textit{Frogger} who will move continuously about as long as either W, A, S, or D are being pressed.

There is an additional callback required for this all to work however: \verb|idleCallback|.
This callback deals with background events and is required for continuous animation.
It can handle background tasks such as updating the positions of non-player characters (a function that will have great use later on in this process).
For now however it will simply take the following form.

\begin{lstlisting}
idle :: IORef Mover -> IdleCallback
idle e = do e $~! id
            postRedisplay Nothing
\end{lstlisting}
$
\section{Other Characters}

\textit{Frogger} is a game of avoiding obstacles, so let's now add some obstacles to be avoided.
This will first require that we extend the \verb|Mover| type to include some "subclasses", in the first instance a \verb|Car| "subclass".

\begin{lstlisting}
data Mover = Frogger {x :: Float
                     ,y :: Float
                     ,s :: Float
           }
           | Car {x :: Float
                 ,y :: Float
                 ,l :: Float
                 ,w :: Float
                 ,v :: Float
           }
\end{lstlisting}

\verb|x| and \verb|y| are common with the \verb|Frogger| "subclass", and will be used with the drawing function we will define later.
\verb|l| and \verb|w| are the length and width of the car respectively; width will likely remain a constant, however length could change depending on what kinds of car obstacles we wish to add to the game.
\verb|v| is the velocity of the car, with the positive direction being left-to-right, or increasing in x.
This will be used in conjunction with a modified version of the \verb|idle| function, discussed later.


We now have to create a containing data type for both the Frogger and the obstacles, such that they can all be stored as one \verb|IORef|.
This is to be the environment variable, and in due course will contain all relevant information about the game, including scores, number of lives, time remaining, and so on.
For now though, it only need include two things: the Frogger and a list of other obstacles.
It can therefore be defined thus:

\begin{lstlisting}
data Env = E {player :: Mover
             ,enemies :: [Mover]
         }
\end{lstlisting}

We can then extend \verb|Display| to include a helper function to draw any \verb|Mover| to the screen.
This will be a two-step function, the first step being a call to \verb|preservingMatrix|, a function in GLUT that stores all of the current transformation information (in this instance the translation and scaling discussed when we first drew a character to the screen).
We can then call a function of our own definition, using pattern matching to ensure the appropriate version of it is called based on what kind of \verb|Mover| we are dealing with - it would not work if we drew the player character identically to a car.

\begin{lstlisting}
drawMover :: Mover -> IO()
drawMover m = preservingMatrix $ drawMover' m

drawMover' :: Mover -> IO()
drawMover' Frogger {x = fx, y = fy, s = fs}
  = do color $ Color3 0.0 1.0 (0.0 :: Float)
       translate $ Vector3 fx fy 0.0
       scale fs fs 1.0
       unitSquare

drawMover' Car {x = cx, y = cy, l = cl, w = cw}
  = do color $ Color3 1.0 0.0 (0.0 :: Float)
       translate $ Vector3 cx cy 0.0
       scale cl cw 1.0
       unitSquare

unitSquare :: IO()
unitSquare
  = let us = [(1,0,0),(1,1,0),(0,1,0),(0,0,0)] :: [(Float, Float, Float)]
    in (renderPrimitive Quads . mapM_ makeVertex) us

makeVertex :: (Float, Float, Float) -> IO ()
makeVertex (x,y,z) -> vertex $ Vertex3 x y z
\end{lstlisting}

Note the additional helper function \verb|unitSquare| - this will be replaced in due course as the game's art becomes more complex however for now we can use it to draw a square of size 1x1 pixel, which we can translate and scale as we wish.
The helper \verb|makeVertex| on the other hand will likely only become more useful as the complexity of drawing increases - it is a useful constructor, taking 3 points and converting them into the data type used by \verb|renderPrimitive|.

\par

Now that we have these we can extend \verb|display| to take as an argument an \verb|IORef Env| rather than an \verb|IORef Mover|, and replace much of the drawing code with the \verb|drawMover| function applied to parts of the environment variable.

\begin{lstlisting}
display :: IORef Env -> DisplayCallback
display m = do clear [ColorBuffer]
               loadIdentity
               fr <- get m
               --putStrLn $ show fr
               translate $ Vector3 (-1.0) (-1.0) (0.0 :: Float)
               scale (1.0/320.0) (1.0/240.0) (0.0 :: Float)
               (drawMover . player) fr
               (sequence . map drawMover . enemies) fr
               swapBuffers
\end{lstlisting}

\begin{figure}[ht]
  \centering
  \caption{The \textit{Frogger} being closed in on by two cars}
  \includegraphics[width=0.5\textwidth]{DrawingEnemies.png}
  \label{fig:drawingenemies}
\end{figure}

As we can see in Figure \ref{fig:drawingenemies}, we can now draw cars to the screen.
By modifying the \verb|idle| function we can also animate them, and with that we can get to the first real glimpse of the game of \textit{Frogger}.

\par

The modification to \verb|idle| is slightly involved, mostly because of the now nested records we have meaning that modifying an internal one is more or less a two-step process.
Fortunately Haskell's \verb|let| syntax makes this process considerably easier, because we can take the internal record value (i.e. the one we want to change) and store it with a different name.
We can then take a helper function, whose role is to update the x position of a mover based on its velocity, and map it across the \verb|enemies| field of the environment variable, thus:

\begin{lstlisting}
idle :: IORef Env -> IdleCallback
idle e = do e $~! \env -> let es = enemies env
                          in env {enemies = map updateMover es}
            postRedisplay Nothing

updateMover :: Mover -> Mover
updateMover c@(Car {x = cx, v = cv}) = c {x = cx + cv}
\end{lstlisting}
$

This two-step processing does also have to be extended to the \verb|input| functions, which leads to a great deal of boilerplate code.

\begin{lstlisting}
input :: IORef Env -> KeyboardMouseCallback
input m c Down _ _
  | c == (Char 'w') || c == (Char 'W')
    = m $~! \e -> let p = player e
                  in e {player = p {y = y p + step}}
  | c == (Char 'a') || c == (Char 'A')
    = m $~! \e -> let p = player e
                  in e {player = p {x = x p - step}}
  | c == (Char 's') || c == (Char 'S')
    = m $~! \e -> let p = player e
                  in e {player = p {y = y p - step}}
  | c == (Char 'd') || c == (Char 'D')
    = m $~! \e -> let p = player e
                  in e {player = p {x = x p + step}}
  | otherwise
    = return ()
  where step = 5
input _ _ _ _ _ = return ()
\end{lstlisting}

The repetition of \verb|let p = player e in e {...| throughout the middle of those guarded functions is both ugly and not especially useful; if that function were to change each individual instance of it would have to, and the more of them that there are, the more likelihood one will be missed.
This has major negative impact on the maintainability of this code, and will have to be addressed.
For now however, we are focussed on getting the game to a point where it is playable.


\pagebreak
%
% HERE BEGINS THE APPENDIX
% IT CONTAINS THE SOURCE CODE FOR A COMPLETE
% IMPLEMENTATION OF EACH CHAPTER'S WORK
%
\appendix

\section{Drawing A Window}
\subsection{Main.hs}
\begin{lstlisting}
module Main where

import Graphics.UI.GLUT
import Display

main :: IO()
main = do (_progName, _args) <- getArgsAndInitialize
          initialWindowSize $= Size 640 480
          createWindow "Frogger"
          displayCallback $= display
          mainLoop
\end{lstlisting}

\subsection{Display.hs}
\begin{lstlisting}
module Display (display) where

import Graphics.UI.GLUT

display :: DisplayCallback
display = do clear [ColorBuffer]
             flush
\end{lstlisting}

\section{Adding A Character}
\subsection{Display.hs}
\begin{lstlisting}
module Display (display) where

import Graphics.UI.GLUT

display :: DisplayCallback
display =
  do clear [ColorBuffer]
     translate $ Vector3 (-1.0) (-1.0) (0.0 :: Float)
     scale (1.0/32.0) (1.0/24.0) (0.0 :: Float)
     color $ Color3 0.0 1.0 (0.0 :: Float)
     let p = [(1,0,0),(1,1,0),(0,1,0),(0,0,0)] :: [(Float,Float,Float)]
     renderPrimitive Quads $ mapM_ (\(x,y,z) -> vertex $ Vertex3 x y z) p
     flush
\end{lstlisting}
%\begin{thebibliography}{0}
%\end{thebibliography}

\end{document}
