\title{Research Into An Existing \textit{Frogger} Implementation}
\author{
  Jack Ellis \\
  psyje5@nottingham.ac.uk\\
  4262333
}
\date{}
\documentclass[12pt]{article}
\usepackage{graphicx}
\graphicspath{ {Images/} }
\usepackage{mathtools}
\usepackage{listings}
\lstset{
  language=Java,
  basicstyle=\ttfamily\small,
  showstringspaces=false
}

\begin{document}
\maketitle
\tableofcontents
\pagebreak

\section{Introduction}
There exist online a great number of Object-Oriented (OO) implementations of the game \textit{Frogger}.
I have chosen GitHub user \verb|vitalius|' implementation (available at \verb|https://github.com/vitalius/frogger|) as the basis of my comparison, because of the number of additional features it has over and above the base "road crossing simulator" idea of Frogger.
In this document I will analyse and discuss these features.

\section{Experience Analysis}
\begin{figure}
  \caption{A screenshot of vitalius' \textit{Frogger} implementation}
  \includegraphics[width=\textwidth]{vitalius.png}
\end{figure}

The basic gameplay revolves around getting a frog from one side of a river to another, via a busy highway and a series of logs.
If the player is hit by a car or falls into the river they lose a life (starting from 5), and must restart from the beginning.
The game is in full colour with smooth animation (meaning the non-player elements that move do so smoothly as opposed to the player, who operates in steps).
Contrary to my original understanding of the game, the player can move in all four directions, meaning they can double back if their current position is unfavourable.
There is a countdown timer set to 60 seconds. If the player does not complete a level within these 60 seconds they lose a life.
The game has two main states: paused and playing; it is not a "true" pause state as all it does is return the game to the initial state as if opened anew.

\subsection{The Road}
There are 6 highway lanes, with alternating vehicle directions, and 2 types of regular vehicle (car and truck), and a special police car which traverses the width of the screen much more quickly than any other object.
Occasionally a heatwave will strike, which causes a particle effect around the player sprite, and causes said sprite to move in a random direction if the player does not move within some timeframe (this will be examined more closely in the source code analysis).

\subsection{The River}
The river stage is much more complex and demanding of the player.
Here the player must navigate a series of moving logs, which carry the player laterally.
If the player is on a log which moves beyond the bounds of the screen the player will fall into the river and lose a life.
Additionally to the logs the river contains turtles and crocodiles, which will carry the player from side to side in the same way as the logs.
However, both carry dangers; while you can move laterally on a crocodile, moving onto its head will see the player "eaten" and lose a life.
The turtles, being of width equal to the players' step size, cannot be moved on.
There is an environmental effect similar to the "heatwave" of the road section, here it is sudden gusts of wind.
This effect has some particle effects shown on screen, but more importantly it slowly moves the player in the direction of the blowing wind.

\section{Source Code Analysis}

The Java project contains 20 files; in this section I will go through each of them individually, in alphabetical order.

The game is built using the Java Instructional Game (JIG) engine, an educational tool developed in response to the fact that, at the time of its release in 2007, \textit{"most of todayâ€™s game engines rely on advanced knowledge of the C++ programming language"}\cite{jig-tutorial}

\subsection{AudioEfx.java}
This file is responsible for the audio effects in the game.

\subsubsection{public void playGameMusic(), 108-110}
This function simply loops the main game theme.

\subsubsection{public void playCompleteLevel(), 112-115}
This function first pauses the game music, then plays the "level complete" sound effect.

\subsubsection{public void playRandomAmbientSound(final long deltaMs), 117-129}
\verb|playRandomAmbientSound| plays, after a predetermined delay, an ambient sound effect.
This effect differs depending on whether the player is on road or on water, and from looking at the resource files can be either a car horn, car passing, or siren if the player is on the road, or a water splash, frog noise, or another kind of splash if they are on the river.

\subsubsection{public void update(final long deltaMs), 131-140}
\verb|update| calls \verb|playRandomAmbientSound|, passing in the current game time, and controls the audio (playing or pausing it depending upon the music's state).

\subsection{Car.java, CopCar.java, Truck.java}
I have bundled these files into one section because they are road-based extensions of \verb|MovingObject|, with largely similar file definitions.

\verb|CopCar| is the most "boring" of the three, having length of one unit, and only one possible sprite to represent it.
\verb|Car| again has length one unit, however has 3 options for representative sprites.
Finally, \verb|Truck| has length of two units, and consequently requires two \verb|CollisionObject|s.

In all cases the constructor sets the correct sprite, the position, adds the objects' \verb|CollisionObject| variable/s to the \verb|collisionObjects| variable, and ensures that the object is in fact drawn on the screen, i.e. making sure that if the objects' \verb|x| position is outside the screen boundaries, drawing is not even attempted.

\subsection{CollisionObject.java}
\verb|CollisionObject| extends a JIG class called \verb|VanillaSphere|, editing it such that its position is offset to the centre of the object to which it relates.

\subsection{Crocodile.java}
This is another extension of \verb|MovingEntity|, with a length of 3 units (as declared in the file).
Interestingly, it sets up 4 \verb|collisionObject|s for use in the \verb|collisionObjects| variable.
Beyond this, the class constructor is much the same as it is for the other \verb|MovingEntity| extensions, with the exception of some variables relating to the current and next frame, as well as the \verb|animationTime| and \verb|animationDelay|, used in the \verb|animate| function.

\subsubsection{public void animate(long deltaMs), 65-72}
This function sets the correct sprite on a per-frame basis such that the crocodile appears to be opening and closing its mouth.
It first adds the current amount of time the game has been running for to the animation time.
If that is now greater than the \verb|animationDelay| (set to 300 by default), it is reset, and the next sprite is chosen.
This occurs in sequence to give the impression of continuous animation.

\subsection{Frogger.java}
This is the main file relating to the player-controlled entity, the eponymous \verb|Frogger|.
It extends \verb|MovingEntity| with a number of variables:
\begin{itemize}
  \item \verb|int MOVE_STEP|\\
    Initialised to 0, this variable appears to denote the length of one player "hop", and is equal to the unit lengths of the cars, trucks, and other obstacles.
  \item \verb|int ANIMATION_STEP|\\
    Initialised to 4, this denotes the length of movement per frame within a hop; a hop takes 8 frames and the player moves a total of 32 pixels per hop.
  \item \verb|int curAnimationFrame|\\
    Initialised to 0, this is used in animation steps to determine whether or not the animation is finished.
  \item \verb|int finalAnimationFrame|\\
    Initialised to \verb|MOVE_STEP/ANIMATION_STEP| (so 8 by default), this is the total number of frames one animation should take.
  \item \verb|long animationDelay|\\
    Initialised to 10, this denotes the number of milliseconds before an animation should begin.
  \item \verb|long animationBeginTime|\\
    Initialised to 0, this is set to the current time at the beginning of any movement.
  \item \verb|boolean isAnimating|\\
    Initialised to \verb|false|, this is set to \verb|true| when the player is moving, and reset to \verb|false| when that movement has finished.
  \item \verb|Vector2D dirAnimation|\\
    Initialised to a new vector with values of 0, this denotes the direction the player should face when they move.
  \item \verb|MovingEntity followObject|\\
    Initialised to \verb|null|, this is used when a player steps on a log in the river stage, and denotes the direction and velocity the Frogger should move without input.
  \item \verb|boolean isAlive|\\
    Initialised to false, this denotes whether or not the player has died. It is set to \verb|true| at the start of a level.
  \item \verb|long timeOfDeath|\\
    Initialised to 0, this is used when resetting the frog with a 2-second delay.
  \item \verb|int currentFrame|\\
    Initialised to 0, this denotes which sprite should be used to represent the Frogger, and is updated depending on the direction the Frogger is facing.
  \item \verb|int tmpFrame|\\
    Initialised to 0, this is used such that the Frogger can return to the correct idle sprite after they have moved.
  \item \verb|int deltaTime|\\
    Initialised to 0, this is used mostly for level timing, taking one second off the game clock per second.
  \item \verb|boolean cheating|\\
    Initialised to \verb|false|, this changes the players' death scenarios making them invulnerable.
  \item \verb|boolean hw_hasMoved|\\
    Initialised to \verb|false|, this is set to \verb|true| whenever the player moves, and is used by the Heatwave event
  \item \verb|Main game|\\
    This is set up in the constructor.
\end{itemize}

\subsubsection{public Frogger(Main g), 72-77}
This is the constructor class, taking as an argument an instance of the main game and drawing the character to the screen.
The argument is stored as the \verb|Main game| variable mentioned earlier.
It resets the frog as well, using \verb|resetFrog()|.

\subsubsection{public void resetFrog(), 82-89}
This function sets \verb|isAlive| to \verb|true|, \verb|isAnimating| to \verb|false|, \verb|currentFrame| to \verb|0|, \verb|followObject| to \verb|null|, \verb|position| to the default starting position, and the game's level timer to its default value.
In essence it resets all of the values in the file to their initial state, except \verb|isAlive|

\subsubsection{public void move$<$Direction$>$(), 94-125}
This section will cover \verb|moveLeft()|, \verb|moveRight()|, \verb|moveUp()|, and \verb|moveDown()|, given that these are all similar enough functions that I do not believe they are worth individual sections.
In each case, the function first checks 3 things: that the player is not trying to pass the boundary of the screen, that the player is alive, and that the Frogger is not currently animating.
If all three of these things are true, it sets the players' sprite to the correct orientation, and calls \verb|move| with a \verb|Vector| of the correct orientation.
It also plays a small sound effect.

\subsubsection{public long getTime(), 131-133}
This function returns the current system time, in milliseconds.

\subsubsection{public void move(Vector2D dir), 144-161}
This function is called in each of the \verb|move<Direction>()| function calls.
It sets \verb|followObject| to \verb|null|, eliminating any "drifting" caused by a player being on a log, sets up a "step" to jump with \verb|curAnimationFrame| and \verb|finalAnimationFrame|, sets \verb|isAnimating| and \verb|hw_hasMoved| to \verb|true|, sets the Frogger's sprite to the correct, animated, state (including setting \verb|tmpFrame| to return to the correct original state), and synchronises the Frogger's collisionSphere with its new position.

\subsubsection{public void updateAnimation(), 166-190}
This function first checks whether or not the Frogger is alive and currently animating.
If one of these is not true, the function synchronises the Frogger's CollisionSphere with its sprite, and returns.
\par
Otherwise, if the value of \verb|curAnimationFrame| is greater than or equal to \verb|finalAnimationFrame| it means the Frogger should have finished animating, and consequently sets the value of \verb|isAnimating| to \verb|false|, and returns the Frogger to the sprite described by \verb|tmpFrame| (the Frogger in its resting state).
\par
If neither of the above are true, and the sum of \verb|animationBeginTime| and \verb|animationDelay| are less than the current time (accessed via a \verb|getTime()| call), the animation will cycle; this is done by updating the position by the value of one step, and incrementing the \verb|curAnimationFrame| variable.

\subsubsection{public void allignXPositionToGrid(), 195-202}
The purpose of this function is to ensure that the Frogger, upon movement, snaps back to the "grid" that makes up its range of movement.
If the Frogger is animating, or it has a \verb|followObject| set, the function does nothing.
If neither of those are the case, the Frogger's x position is rounded to the nearest multiple of 32 (the size of one "step").

\subsubsection{public void updateFollow(long deltaMs), 208-213}
\verb|updateFollow| allows the Frogger to follow a log on the river by taking its velocity vector.
To do this, it first checks that the the Frogger a) has a \verb|followObject| set, and b) is alive.
If both of these are true, it updates the Frogger's position using the \verb|followObject|'s velocity vector.

\subsubsection{public void follow(MovingEntity log), 219-221}
This function sets the Frogger to have a \verb|followObject| when it steps on a log.

\subsubsection{public void windReposition(Vector2D d), 228-234}
This function enforces the "random wind gust" environmental effect, by moving the Frogger to a new position described by the Frogger's current location and the argument \verb|d|.
It also sets \verb|hw_hasMoved| to true, and does all of this only if the Frogger is alive.

\subsubsection{public void randomJump(final int rDir), 240-254}
This function enforces the "heatwave" environmental effect, by moving the frogger one "step" in a random direction descirbed by \verb|rDir|.

\subsubsection{public void die(), 259-274}
If the Frogger is currently animating it cannot die, and as such this function does nothing if that is the case.
If the player is not cheating, the function plays a sound effect, sets \verb|followObject| to \verb|null|, \verb|isAlive| to \verb|false|, and \verb|hw_hasMoved| to \verb|true|.
It then sets the Frogger to the "dead" sprite, and decrements the number of lives the player has left.
Regardless of whether or not the player is cheating, the \verb|timeOfDeath| variable is set to the current time, and the level's timer is set to the default value.

\subsubsection{public void reach(final Goal g), 279-294}
This function is only called upon the Frogger reaching the end of the level.
If the \verb|Goal|'s \verb|isReached| variable is \verb|false|, it plays the relevant sound effect, adds 100 to the \verb|Game|'s score and adds the total score to the level timer.
If the player has landed on a bonus goal another sound effect is played, and the player gains a life.
\par
If the \verb|Goal|'s \verb|isReached| variable is \verb|true|, the Frogger's position is set to the same as the \verb|Goal|'s.

\subsubsection{public void update(final long deltaMs), 296-317}
This function deals with level timing and general animation update work.
If the player has run out of lives, it does nothing; if the player is dead it keeps them that way for two seconds.
Otherwise it updates the Frogger's animation (via an \verb|updateAnimation()| call), follow position (via \verb|updateFollow|), and sets the correct sprite frame.
Every 1000ms it decrements the game's timer by 1, and if that timer reaches 0 it kills the player.


\subsection{FroggerCollisionDetection.java}
This purpose of this class is to detect when the Frogger has collided with another object.
It has 6 declared variables:
\begin{itemize}
  \item \verb|public Frogger frog|\\
        The Frogger itself; this is given a value on object creation.
  \item \verb|public CollisionObject frogSphere|\\
        The Frogger's collision sphere; this is given a value on object creation.
  \item \verb|public int river_y0|\\
        The lower y-bound of the first river lane.
        This is set to \verb|1*32|, or one grid step up.
  \item \verb|public int river_y1|\\
        The upper y-bound of the last river lane.
        This is set to \verb|river_y0 + (6*32)|, 6 "lanes" up from \verb|y0|.
  \item \verb|public int road_y0|\\
        The lower y-bound of the first road lane.
        This is set to \verb|1*32|, or one grid step up.
  \item \verb|public int road_y1|\\
        The upper y-bound of the last road lane.
        This is set to \verb|road_y0 + (6*32)|, 6 "lanes" up from \verb|y0|.
\end{itemize}

\subsubsection{public FroggerCollisionDetection(Frogger f), 43-46}
This function instantiates an instance of \verb|FroggerCollisionDetection|, setting both the \verb|frog| and \verb|frogSphere| variable.

\subsubsection{public void testCollision(AbstractBodyLayer$<$MovingEntity$>$), 48-76}
This function tests whether or not the frog is touching any other objects on the map.
If the frog isn't alive, it returns empty, otherwise it sets a variable denoting the Frogger's current position and declares a \verb|double| called \verb|dist2|.
If the frog is out of bounds (checked by the function \verb|public boolean isOutOfBounds()|), the player dies.
Else it checks every \verb|MovingEntity| in its argument as follows: if that entity is inactive, skip it.
For every \verb|CollisionObject| that entity has stored, calculate the distance between them using Pythagoras, and check that against the centre position of the frog.
If they collide, call the \verb|collide| function and return.
Finally, if the Frogger is in the river, the player dies.

\subsubsection{public boolean isOutOfBounds(), 90-97}
This function takes the centre position of the Frogger, and if it is outside the bounds of the map returns \verb|true|, else it returns \verb|false|

\subsubsection{public boolean isOnRoad() \& public boolean isOnRiver(), 103-110 \& 116-123}
These two functions are similar enough that they can be described in the same section.
Both functions check the Frogger's position in \verb|y|, returning true if it is between the bounds described by \verb|road_y0| and \verb|road_y1|, and \verb|river_y0| and \verb|river_y1| respectively.

\subsubsection{public void collide(MovingEntity m, CollisionObject s), 125-153}
This function deals with collisions between the Frogger and other \verb|MovingEntity|s on the screen, selecting the correct function for the Frogger object given by \verb|frog| to perform based on what it collides with.

It is essentially a giant switch/case statement, checking what the \verb|MovingObject| is an instance of;
\begin{itemize}
  \item If \verb|m| is a \verb|Truck|, \verb|Car|, or \verb|CopCar|, the Frogger dies.
  \item If \verb|m| is a \verb|Crocodile|, the function checks whether or not the Frogger is on its head or body.\\
        If the Frogger is on its head, the Frogger dies.\\
        Otherwise, the Frogger is set to be \verb|follow|ing it.
  \item If \verb|m| is a set of \verb|Turtles|, the function checks whether or not those turles are underwater or not.\\
        If they are, the Frogger dies.\\
        Otherwise, the Frogger is set to \verb|follow| the \verb|Turtles|.
  \item Finally, if \verb|m| is a \verb|Goal|, the Frogger calls \verb|reach|, and the level is complete.
\end{itemize}


\subsection{FroggerUI.java}
This class has 8 class variables:
\begin{itemize}
  \item The following 5 are all variables which store the relevant sprite information for various game mechanics.
    \begin{itemize}
      \item \verb|List<ImageResource> heart|\\
            These are the hearts at the top-left of the screen which represent the number of lives the player has left.
      \item \verb|List<ImageResource> gameOver|\\
            This is the "Game Over" message.
      \item \verb|List<ImageResource> levelFinish|\\
            This is the "Level Complete" message.
      \item \verb|List<ImageResource> introTitle|\\
            This is the "Splash Screen", displayed at the start of the game.
      \item \verb|List<ImageResource> instructions|\\
            This is the "Help Screen", accessible by pressing \verb|h| while on the splash screen.
    \end{itemize}
  \item \verb|FontResource font|\\
        This sets the correct font for instances when the text is on a dark background.
  \item \verb|FontResource fontBlack|\\
        This sets the correct font for instances when the text is on a light background.
  \item \verb|Main game|\\
        This is an instance of the \verb|Main| class, which the UI layer can interact with to determine game states and make perform functions.
\end{itemize}

\subsubsection{public FroggerUI(final Main g), 59-61}
This function instatiates an instance of \verb|FroggerUI|, and provides the \verb|Main| instance taken by the \verb|game| variable.

\subsubsection{public void render(RenderingContext rc), 64-118}
This function first renders the game's time and score at the top of the screen.
If the player has more than 0 lives, it then sets a variable \verb|dx| to 0, and using that draws all of the players' hearts at the top-left of the screen, capping it at a maximum of 10 rendered hearts (the player can have more than 10 lives, but only a maximum of 10 will be drawn).
The game's level is then placed at the top of the screen.
Now there is ostensibly a large switch/case statement that draws the relevant screen depending upon the value of the \verb|game| object's \verb|gameState| variable.

\subsubsection{public void update(long deltaMs), 120-121}
This function is empty, and simply overrides the superclass' \verb|update| function.

\subsubsection{public boolean isActive(), 123-125}
This function always returns \verb|true|; the layer is always active.

\subsubsection{public void setActivation(boolean a), 127-129}
This function does nothing, and similarly to \verb|update| only appears to override the superclass' version of it.
This function does nothing because the layer is always active, and consequently there is no need to set its activation.

\subsection{Goal.java}
This class has two variables associated with it:
\begin{itemize}
  \item \verb|public boolean isReached|\\
        Set to \verb|false| initially, this is set to \verb|true| if the Frogger reaches it.
  \item \verb|public boolean isBonus|\\
        Set to \verb|false| initially, this is set to \verb|true| if the goal is set as a bonus.
\end{itemize}

\subsubsection{public Goal(int loc) \& public Goal(Vector2D pos), 34-40 \& 42-48}
These two functions are overloaded constructors, hence they can be described in one section.
First they set the sprite to the goal one, and then they set their position.
The \verb|int| instance sets the position to the top of the screen and some number of player "steps" either side of the middle of the screen.
The \verb|Vector2D| instance sets the position to the exact one described by the argument.
In both cases the \verb|collisionObjects| variable has added to it the details of the \verb|Goal| being constructed, the position synchronised within the global \verb|collisionObjects| list, and the correct sprite frame is selected.

\subsubsection{public void reached(), 50-30}
This function sets \verb|isReached| to \verb|true|, and changes the frame of the \verb|Goal|'s sprite to one denoting success.

\subsubsection{public void setBonus(boolean b), 55-63}
If the \verb|boolean| argument is \verb|true|, the \verb|Goal| is set to be a bonus, conferring more rewards for reaching it, and changing its sprite to denote a bonus.
If the argument is \verb|false|, it unsets the bonus flag, and returns the sprite to a normal \verb|Goal| one.

\subsubsection{public void update(long deltaMs), 65-67}
This is an empty function whose purpose is solely to override the superclass' instance.

\subsection{GoalManager.java}
This class deals with generating and keeping track of all \verb|Goal|s in the game.
It has 8 variables in the class:
\begin{itemize}
  \item \verb|final static int MAX_NUM_OF_GOALS|\\
        Initialised to 6, this variable stores the maximum number of goals a single level can have.
  \item \verb|private List<Goal> goals|\\
        This keeps track of all of the \verb|Goal|s in the level.
  \item \verb|private Random r|\\
        This is a random series of integers, used when setting \verb|Goal|s to bonus and back.
  \item \verb|protected boolean showingBonus|\\
        Initialised to \verb|false|, this sets whether or not there is a bonus \verb|Goal| on the screen at all.
  \item \verb|private int bonusRateMs|\\
        Initialised to 5000, this variable sets how long there should be between the presence of bonus \verb|Goal|s
  \item \verb|private int bonusShowMs|\\
        Initialised to 5000, this variable sets how long a \verb|Goal| should be set as a bonus for.
  \item \verb|private int dRMs|\\
        Initialised to 0, this variable times how long it has been between bonuses being present.
  \item \verb|private int dSMs|\\
        Initialised to 0, this variable times how long a bonus has been present on the screen for.
\end{itemize}

\subsubsection{public GoalManager(), 49-53}
This is the class constructor; it sets the \verb|goals| variable to be a linked list of \verb|Goal| objects, initiall empty, sets \verb|r| to be a new Java \verb|Random| based on the current time, and calls \verb|init| with the value of the first level, which is 1.

\subsubsection{public void init(final int level), 62-85}
This function first clears the \verb|goals| variable, then a switch/case statement based on the current level sets the relevant number of \verb|Goal|s to be on screen.
There is a comment above this function which states that level 1 has 2 goals, 2 has 4, and all others have 6, however this code shows that in fact level 1 has 2 goals, and the rest have 4.

\subsubsection{public List$<$Goal$>$ get(), 91-93}
This function returns the \verb|goals| variable.

\subsubsection{public List$<$Goal$>$ getUnreached(), 99-106}
This function is similar to \verb|get|, however it returns a new list it constructs from \verb|Goal|s whose \verb|isReached| flag is \verb|false|.

\subsubsection{public void doBonusCheck(), 112-118}
This function consists of two if-statements.
This first checks if a bonus is not currently being shown and that the current time between bonuses being shown is greater than the bonus rate.
If both of those are \verb|true|, \verb|dSMs| is set to 0, \verb|showingBonus| to true, and a random unreached \verb|Goal| in \verb|goals| is set to be a bonus.
The second if-statement checks if a bonus is currently being shown and that the current time it has been shown for is greater than the show rate.
If both of those are true, \verb|dRMs| is set to 0, \verb|showingBonus| to false, and each \verb|Goal| in \verb|goals| has the bonus flag set to \verb|false|.

\subsubsection{public void update(long deltaMs), 129-133}
This function adds \verb|deltaMs| to both \verb|dRMs| and \verb|dSMs|, and then runs \verb|doBonusCheck|.


\subsection{HeatWave.java}
This class has 6 variables associated with it:
\begin{itemize}
  \item \verb|final static int PERIOD|\\
        Initialised to 2000, this is the time between heatwave events.
  \item \verb|final static int DURATION|\\
        Initialised to 1000, this is the duration of one heatwave event.
  \item \verb|Random r|\\
        This is a Java \verb|Random| variable, used in determining whether or not a random event happens.
  \item \verb|private long timeMs|\\
        This is set to 0 initially, and is checked against the \verb|PERIOD| variables when determining whether or not a heatwave should happen.
  \item \verb|private long durationMs|\\
        Similar to \verb|timeMs|, this is checked against the \verb|DURATION| variable when determining whether or not a heatwave should finish.
  \item \verb|private long heatWaveMs|\\
        This variable tracks how long a heatwave event has been occurring for.
  \item \verb|public boolean isHot|\\
        Initialisd to \verb|false|, this determines whether or not a heatwave event is occurring.
\end{itemize}

\subsubsection{public HeatWave(), 44-49}
This is the class constructor, and sets the values of \verb|isHot|, \verb|timeMs|, and \verb|heatWaveMs|, to \verb|true|, \verb|0|, and \verb|0| respectively.
It also instantiates \verb|r| with a new \verb|Random| object.

\subsubsection{public void perform(Frogger f, insal long deltaMs, final int level), 56-69}
This function enforces the effect of the heatwave itself; namely that if a heatwave begins and the player does not move within a certain time (directly proportional to the level), the Frogger will jump in a random direction.
if the Frogger is not alive, \verb|isHot| is set to \verb|false| and the function returns.
Otherwise, if it \verb|isHot| and the duration of the heatwave is less than the defined limit, and the player has not moved in that time, a random jump occurs and \verb|isHot| is set to false.
Finally, if the player has moved, \verb|isHot| is set to false.

\subsubsection{public void start(Frogger f, final int GameLevel), 77-88}
Here it is determined whether or not a heatwave event should start; if it is not currently "hot", and the time since the last heatwave check is greater than the period between heatwaves, the check time is set to 0.
Then, if the next random integer chosen by \verb|r| is less than the game's level multiplied by 10, \verb|durationMs| is set to 1, \verb|isHot| to \verb|true|, the Frogger's \verb|hw_hasMoved| variable to \verb|false|, and a heatwave-y sound effect plays.

\subsubsection{public MovingEntity genParticles(Vector2D pos), 96-107}
This generates the particles that appear around the Frogger when a heatwave event is occurring.
If it is not hot, or \verb|r| returns an integer greater than 10, it does nothing; else it returns a new \verb|MovingEntity| with a particulate sprite, which is drawn to the screen.

\subsubsection{public int computeHeatValue(final long deltaMs, final int level, int curTemp), 114-125}
This function only appears in this file, at this point; it is as yet unclear as to whether or not it is a part of some call somewhere withing the JIG however as it stands it does nothing.
Regardless, were it to be called it would increment \verb|heatWaveMs| by the value of the \verb|deltaMs| argument.
From this, every two seconds it increases the game's temperature by 1, and resets heatWaveMs to 0, capping it at 170.

\subsubsection{public void update(final long deltaMs), 127-130}
This increases both \verb|timeMs| and \verb|durationMs| by the value of the \verb|deltaMs| argument.

\subsection{LongLog.java}
This file contains only the constructor for the \verb|LongLog| class.

This sets up what is effectively 4 \verb|MovingEntities| joined together, and gives them a velocity described by the arguments passed in.

\subsection{Main.java}
The \verb|Main| class is the controller class for the entire game.
All of the functions herein are of type \verb|void|, given that they affect screen events or global/class variables.

In its declaration it creates an instance of its superclass, namely \verb|StaticScreenGame| (a class declared within the JIG engine), with the desired height and width of the game screen, and preferring to be left in a window as opposed to taking up the full screen.
It then sets the window's title to "Frogger", and loads its resources from the file \verb|resources.xml|, a file containing the names of all of the audio and image files for sprites and such.
It sets up the background of the frame based on the filename referenced herein, and applies it to the window.
Following this, the function sets up the collision detection by generating two spheres.
Finally, it generates instances of all of the classes declared in other files, and calls the member function \verb|initializeLevel|, passing in the value 1 as the argument.

\subsubsection{public void initializeLevel(int level), 131-178}
This function sets up the level for the game, first clearing the screen of all moving objects then generating the 5 river lanes and 5 road lanes.
Within this it sets the general speeds for objects within these lanes based on the variable \verb|dV|, which itself is proportional to the level the player has reached.

Once this is done, it generates the objective, called the Goal, and and cycles the traffic generator 500 times to generate some cars before the game is launched.

\subsubsection{public void cycleTraffic(long deltaMs), 186-229}
\verb|cycleTraffic|, per the name, is responsible for generating and cycling traffic elements across the road lanes, and is between lines 186 and 229.
The road lanes all have the same constructor, \verb|buildVehicle|, which implies that any vehicle has equal chance of appearing on any lane.
The river lanes, by comparison, alternate with regard to what can populate them.
All 5 lanes can have logs, however lanes 1, 3, and 5 will have short logs interspersed with turtles (generated by \verb|buildShortLogWithTurtles|), whereas lanes 2 and 4 will have longer logs interspersed with crocodiles (generated by \verb|buildLongLogWithCrocodile|).
If the wind or heatwave events are in effect, it will draw the relevant particle effects for them.
In each case for the road/river lanes, it will update them if they are present, or create and add them to the \verb|movingObjectsLayer| if they are not.

\subsubsection{public void froggerKeyboardHandler(), 234-281}
\verb|froggerKeyboardHandler|, as the name suggests, deals with keyboard inputs while the game is in progress.
It first polls the keyboard to determine whether or not a key is being pressed, and updates a series of \verb|boolean|s based on whether or not the keys associated with them have been pressed.
Before dealing with the results of those booleans it determines whether or not the user is cheating.
Here, cheating means activating/deactivating cheat mode by pressing \verb|c| or \verb|v| respectively, or skipping to level 10 by pressing the \verb|0| key.
Next it updates the \verb|keyPressed| and \verb|keyReleased| variables depending on whether or not a key has been pressed.
The boolean variable \verb|listenInput|, declared at the top of the class file (line 92) determines whether or not the game acts upon the users' input; this means that the user cannot hold down a key and the frog move continuously, rather that the if the user wishes to move 4 squares to the right they must press the right key 4 times.
If the keys have been released \verb|listenInput| is set to \verb|true|, so that the game can listen for another key press, and \verb|keyPressed| is set to false.
Finally, if the user has pressed the escape key the game is set back to the intro state (the variable \verb|GameState| is set to 0).

\subsubsection{public void menuKeyboardHandler(), 286-317}
There is a separate handler for keyboard events while the game is in the menu state, called \verb|menuKeyboardHandler|.
Again it begins by polling the keyboard, and if the space key is not pressed it sets the class boolean \verb|space_has_been_released| to \verb|true|; if that variable is \verb|false| it will \verb|return|, and finish the function there.
If the space bar is being pressed it has a number of actions to take based upon the games' state.
If the game is over, or the user is looking at the instructions, it will return them to the game's intro state and allow them to start again.
Otherwise it will start the game again, resetting the number of lives, score, level, timer, frog position, game state, music playing, and starting the level via \verb|initializeLevel|.
If the user presses \verb|h| in the menu they will recieve instructions about how the game works.

\subsubsection{public void finishLevelKeyboardHandler(), 322-329}
There is then a function to deal with keyboard inputs on the finish of a level, \verb|finishLevelKeyboardHandler|.
If the space key is pressed it will initialise a new level, one greater than the previous one, and return to the game state.
This function seems out of place, as in my gameplay testing the game automatically increments the level without the user pressing space.

\subsubsection{public void update(long deltaMs), 335-388}
\verb|update| is, I believe, run on every cycle of the game.
It is ostensibly one giant \verb|switch/case| statement, with cases for each game state.
In the case that the game is being played it will take the keyboard input and deal with it as described in \verb|froggerKeyboardHandler|, update the wind, heatwave, frog, audio, ui, and traffic with the current game time, and test for collisions, before applying wind or heatwave effects where appropriate.
If the player has lost a life it clears the particle layer (which is where the particle effects for wind and heat are drawn).
Otherwise, if the goal has been reached it will move to the level finish state, play a sound effect, and clear the particle layer.
If the player has run out of lives it will move to the game over state and the game will start again.
In the case that the game is over, the player is reading the instructions, or the game is on the intro menu, it will update the goal manager and cycle the traffic with the time since the game has started, and await user input.
In the case that the level has finished it will call the \verb|finishLevelKeyboardHandler| and it will perform as described above.

\subsubsection{public void render(RenderingContext rc), 394-421}
This function is responsible for rendering the contents of the screen.
Again, it is ostensibly one large \verb|switch/case| statement, doing different things depending upon the state of the game.
If the game is in progress (i.e. in states \verb|GAME_FINISH_LEVEL| or \verb|GAME_PLAY|), it renders the map of the game as well as the many moving objects that make up the obstacles and player sprite, and any particle effects created by the environmental effects..
If the game is in a pause state (i.e. \verb|GAME_OVER|,\verb|GAME_INSTRUCTIONS|, or \verb|GAME_INTRO|) it renders everything as before with the exception of the Frogger and particle effects.

\subsubsection{public static void main(String[] args), 423-427}
This is the function that is called on the \verb|.jar| file being run.
In creates a new Main object, and calls \verb|run| on it.

\subsection{MovingEntity.java}
This class is the superclass for all objects on the screen that move, specifically the player, cars, and river obstacles.
It extends the \verb|Body| class from the JIG with a linked list of \verb|CollisionObject|s.
This linked list will contain all other objects on the screen as well as their "hitboxes", for use in determining collisions.

\subsubsection{public void sync(Vector2D position), 64-72}
\verb|sync| updates the list of \verb|CollisionObject|s within the \verb|MovingEntity| object with the new position of the \verb|MovingEntity|.

\subsubsection{public void update(final long deltaMs), 82-90}
\verb|update| first checks if the position of the \verb|MovingEntity| is outside the bounds of the world.
Here it does this only for the X-axis, because the majority of objects only move on said axis, and the \verb|Frogger| class has an overriding implementation.
It then updates the position of the \verb|MovingEntity| based on its old position and current velocity, after which it calls \verb|sync| with that new position.

\subsection{MovingEntityFactory.java}
This class deals with the creation of all \verb|MovingEntities| in the game.
It has 12 class variables:
\begin{itemize}
  \item The following essentially convert the subclass of \verb|MovingEntity| to be created, and are used in conjunction with the \verb|creationRate| variable described below.
    \begin{itemize}
      \item \verb|public static int CAR|\\
            Set to \verb|0|, this denotes the \verb|Car| class to be created.
      \item \verb|public static int TRUCK|\\
            Set to \verb|1|, this denotes the \verb|Truck| class to be created.
      \item \verb|public static int SLOG|\\
            Set to \verb|2|, this denotes the \verb|ShortLog| class to be created.
      \item \verb|public static int LLOG|\\
            Set to \verb|3|, this denotes the \verb|LongLog| class to be created.
    \end{itemize}
  \item \verb|public Vector2D position|\\
        This determines the position of the \verb|Factory|.
  \item \verb|public Vector2D velocity|\\
        This determines the velocity of the objects produced by the \verb|Factory|
  \item \verb|public Random r|\\
        A random-number generator.
  \item \verb|private long updateMs|\\
        This is used when creating a new \verb|MovingObject| to ensure it happens at the correct intervals.
  \item \verb|private long copCarDelay|\\
        This is used similarly to the above, however is only used when a \verb|CopCar| is trying to be made.
  \item \verb|private long rateMs|\\
        This determines the rate at which the \verb|Factory| checks whether or not to spawn a new \verb|MovingEntity|.
  \item \verb|private int padding|\\
        This is the minimum distance between two \verb|MovingObject|s in a lane.
  \item \verb|private int[] creationRate|\\
        This is an array of integers that determine the rate at which \verb|MovingEntities| should be created depending on what type they are.
\end{itemize}

\subsubsection{public MovingEntityFactory(Vector2D pos, Vector2D v), 59-72}
The constructor, this takes sets the \verb|position| and \verb|velocity| variables to the values passed in as arguments.
It then sets up \verb|r| with a new random number generator, and gives values to all items in the \verb|creationRate| variable based on their lengths and the \verb|Factory|'s \verb|velocity| variable.

\subsubsection{public MovingEntity buildBasicObject(int type, int chance), 81-105}
This is the basic factory method created for each lane.
If the \verb|updateMs| variable is greater than the \verb|rateMs| variable, it has a chance described by the \verb|chance| argument to create a new \verb|MovingEntity| of type described by the \verb|type| argument, with the \verb|position| and \verb|velocity| variables set to those of the \verb|Factory|.

\subsubsection{public MovingEntity buildShortLogWithTurtles(int chance), 107-112}
This function is the factory function for the lanes which have a chance of building either a \verb|ShortLog| or a series of \verb|Turtles|.
The function calls \verb|buildBasicObject| with an 80\% chance of building a \verb|ShortLog|; if it does not, and the \verb|chance| argument is less than another random number under 100 it will create a new series of turtles with a random 50/50 chance of being underwater initially.

\subsubsection{public MovingEntity buildLongLogWithCrocodile(int chance), 118-123}
Similarly to \verb|buildShortLogWithTurtles|, this first attempts to build a \verb|LongLog| using \verb|buildBasicObject|; if it does not it has a \verb|chance| argument\% chance to build a \verb|Crocodile|.

\subsubsection{public movingEntity buildVehicle(), 130-147}
This function is used to create \verb|Car|s, \verb|Truck|s, and \verb|CopCar|s.
It creates a new \verb|MovingEntity m|, with an 80\% chance of being a \verb|Car| and a 20\% chance of being a \verb|Truck|; if that \verb|MovingEntity| is created successfully, and the absolute value of its velocity (multiplied by the \verb|copCarDelay| variable) is less than the wdth of the world, that \verb|MovingEntity| will be replaced with a \verb|CopCar|.
Either way, the \verb|copCarDelay| variable is reset to 0, and if a \verb|CopCar| isn't spawned, \verb|m| is returned.

\subsubsection{public void update(final long deltaMs), 149-152}
This function increments \verb|updateMs| and \verb|copCarDelay| by the value of \verb|deltaMs| passed in by the argument.


\subsection{Particle.java}
This class extends \verb|MovingEntity|, and has 2 variables associated with it:
\begin{itemize}
  \item \verb|private int timeExpire|\\
        Initialised to 1, this is the time before a \verb|Particle| shold expire.
  \item \verb|private int timeAlive|\\
        Initialised to 1, this is the time for which a \verb|Particle| has been alive.
\end{itemize}

\subsubsection{public Particle(String sprite, Vector2D pos, Vector2D v, int te), 58-64}
The class constructor, this creates a new \verb|MovingEntity| with a sprite, position, and velocity described by the \verb|sprite|, \verb|pos|, and \verb|v| arguments respectively.
The \verb|te| argument is passed into the \verb|timeExpire| variable, and the whole object is activated by a \verb|setActivation(true)| call.

\subsubsection{public void update(final long deltaMs), 66-75}
This updates the whole object based on the \verb|MovingEntity|'s \verb|update| function, with the added step of checking whether or not the \verb|Particle| should have expired by now; this is done by adding the \verb|deltaMs| arguement to the \verb|timeAlive| variable, and checking that against \verb|timeExpire|.
If \verb|timeAlive| is greater than \verb|timeExpire|, the object is deactivated via a \verb|setActivation(false)| call.

\subsection{ShortLog.java}
This class is an extension of the \verb|MovingEntity| class, and has only one additional variable, \verb|public static int LENGTH|, which is initialised to 32*3 (96).

\subsubsection{public ShortLog(Vector2D pos, Vector2D v), 33-47}
This is the class constructor, which sets the sprite via a \verb|super| call.
It then sets the position and velocity based on the \verb|pos| and \verb|v| arguments respectively, and adds the collosion spheres as offsets from the \verb|position| variable.
If the x-value of \verb|v| is less than 0 the frame is set to 1, otherwise it's set to 0.

\subsection{Turtles.java}
This class extends \verb|MovingEntity|, and has 11 variables associated with it:
\begin{itemize}
  \item \verb|private long underwaterTime|\\
        Initialised to 0, this is the amount of time the \verb|Turtles| have been underwater for.
  \item \verb|private long underwaterPeriod|\\
        Initialised to 1200, this is the time for which the \verb|Turtles| should be underwater.
  \item \verb|protected boolean isUnderwater|\\
        Initialised to \verb|false|, this determines whether or not the \verb|Turtles| are underwater.
  \item \verb|private boolean isAnimating|\\
        Initialised to \verb|false|, this determines whether or not the \verb|Turtles| are animating.
  \item \verb|private long localDeltaMs|\\
        
  \item \verb|private long startAnimatingMs|\\
  \item \verb|private long timerMs|\\
  \item \verb|private long animatingPeriod|\\
        Initialised to 150, this is the number of milliseconds one animation cycle should take.
  \item \verb|private int aFrame|\\
        Intialised to 0, this is the current animation frame.
  \item \verb|private int max_aFrame|\\
        Initialised to 2, this is the maximum number of animation frames allowed.
\end{itemize}

\subsubsection{public Turtles(Vector2D pos, Vector2D v, int water), 76-89}
The class constructor, this sets the sprite via a \verb|super()| call, and calls \verb|init| with the \verb|pos| and \verb|v| arguments passed through.
If the \verb|water| argument is 0, \verb|isUnderwater| is set to \verb|false|, else it is set to \verb|true|, and the frame is incremented by 2.

\subsubsection{public void init(Vector2D pos, Vector2D v), 99-114}
The \verb|position| variable is set to the \verb|pos| argument, and 2 additional collision spheres are created as offets.
The \verb|velocity| variable is set to the value of the \verb|v| argument, and the correct sprite frame is set based on the direction the \verb|Turtles| are travelling.

\subsubsection{public void checkAirTime(), 120-126}
This first increments the \verb|underwaterTime| variable by the value of \verb|localDeltaMs|, and if it becomes greater than the value of \verb|underwaterPeriod| it goes into the other state (underwater to floating or vice-versa).

\subsubsection{public void animate(), 133-152}
If the \verb|isAnimating| flag is set to false, this function does nothing.
Beyond that, if the \verb|timerMs| variable is greater than the \verb|startAnimatingMs| variable, it will animate one step of either returning to the surface or submerging.
If the \verb|aFrame| variable is greater than or equal to the \verb|max_aFrame| variable, it stops the animation.

\subsubsection{public void startAnimation(), 159-164}
This sets up the animation by setting \verb|isAnimating| to \verb|true|, and \verb|startAnimatingMs|, \verb|timerMs|, and \verb|aFrame| to 0.

\subsubsection{public void update(final long delta), 166-172}
This first performs the superclass' \verb|update| function, then sets \verb|localDeltaMs| to the \verb|deltaMs| argument, which it then uses to incremend the \verb|timerMs| variable.
It then performs \verb|checkAirTime()| and \verb|animate()|.

\subsection{Windgust.java}
This class has 6 variables associated with it:
\begin{itemize}
  \item \verb|final static int PERIOD|\\
        Intiailised to 5000, this is the period between wind gust event checks in milliseconds.
  \item \verb|final static int DURATION|\\
        Initialised to 3000, this is the duration of wind gusts in milliseconds.
  \item \verb|Random r|\\
        This is a random number generator used in determining whether or not a gust actually occur.
  \item \verb|private long timeMs|\\
        This is a variable containing the current game time, in milliseconds.
  \item \verb|private long durationMs|\\
        This is used to check how long a wind gust has been occuring for.
  \item \verb|private boolean isWindy|\\
        A flag denoting whether or not a wind gust event is currently occuring.
\end{itemize}

\subsubsection{public WindGust(), 49-43}
This is the constructor, which initialises \verb|timeMs| to 0, \verb|isWindy| to \verb|false|, and initialises \verb|r| with a new random number generator.

\subsubsection{public void perform(Frogger f, int level, final long deltaMs), 60-72}
If the Frogger is not alive, this function sets \verb|isWindy| to \verb|false| and \verb|return|s.
Otherwise, \verb|isWindy| and \verb|durationMs| are checked, the latter against being smaller than \verb|DURATION|, and if both of those are true, it sets the wind position randomly.
Otherwise it sets \verb|isWindy| to \verb|false|.

\subsubsection{public void start(final int level), 79-92}
This begins a new level; if it isn't currently windy and the value of \verb|timeMs| is greater than the \verb|PERIOD| variable, it has a chance of starting a new wind event, setting \verb|durationMs| to 1, \verb|isWindy| to \verb|true|, and playing a sound effect.
Either way it resets \verb|timeMs| to 0.

\subsubsection{public MovingEntity genParticles(final int level), 100-115}
This function, similar to other \verb|genParticles| functions, generates the particle overlay that appears when a wind event occurs.

\subsubsection{public void update(final long deltaMs), 117-120}
This increments \verb|timeMs| and \verb|durationMs| by the value of the \verb|deltaMs| argument.


\begin{thebibliography}{0}
  \bibitem{jig-tutorial}
    Wallace, Scott A. and Nierman, Andrew\\
    Using the Java Instructional Game Engine in the Classroom\\
    December 2007\\
    Available at http://dl.acm.org/citation.cfm?id
    Accessed 2018-10-26
\end{thebibliography}

\end{document}
